<!DOCTYPE HTML>
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc -->
<title>LambdaMetafactory (Java SE 12 &amp; JDK 12 )</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="keywords" content="java.lang.invoke.LambdaMetafactory class">
<meta name="keywords" content="FLAG_SERIALIZABLE">
<meta name="keywords" content="FLAG_MARKERS">
<meta name="keywords" content="FLAG_BRIDGES">
<meta name="keywords" content="metafactory()">
<meta name="keywords" content="altMetafactory()">
<link rel="stylesheet" type="text/css" href="../../../../stylesheet.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../../jquery/jquery-ui.css" title="Style">
<script type="text/javascript" src="../../../../script.js"></script>
<script type="text/javascript" src="../../../../jquery/jszip/dist/jszip.min.js"></script>
<script type="text/javascript" src="../../../../jquery/jszip-utils/dist/jszip-utils.min.js"></script>
<!--[if IE]>
<script type="text/javascript" src="../../../../jquery/jszip-utils/dist/jszip-utils-ie.min.js"></script>
<![endif]-->
<script type="text/javascript" src="../../../../jquery/jquery-3.3.1.js"></script>
<script type="text/javascript" src="../../../../jquery/jquery-migrate-3.0.1.js"></script>
<script type="text/javascript" src="../../../../jquery/jquery-ui.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="LambdaMetafactory (Java SE 12 & JDK 12 )";
        }
    }
    catch(err) {
    }
//-->
var data = {"i0":9,"i1":9};
var tabs = {65535:["t0","All Methods"],1:["t1","Static Methods"],8:["t4","Concrete Methods"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";
var pathtoroot = "../../../../";
var useModuleDirectories = true;
loadScripts(document, 'script');</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<header role="banner">
<nav role="navigation">
<div class="fixedNav">
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a id="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<a id="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../index.html">Overview</a></li>
<li><a href="../../../module-summary.html">Module</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="class-use/LambdaMetafactory.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../index-files/index-1.html">Index</a></li>
<li><a href="../../../../help-doc.html">Help</a></li>
</ul>
<div class="aboutLanguage"><div style="margin-top: 14px;"><strong>Java SE 12 &amp; JDK 12</strong> </div></div>
</div>
<div class="subNav">
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li><a href="#field.summary">Field</a>&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li><a href="#field.detail">Field</a>&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<ul class="navListSearch">
<li><label for="search">SEARCH:</label>
<input type="text" id="search" value="search" disabled="disabled">
<input type="reset" id="reset" value="reset" disabled="disabled">
</li>
</ul>
</div>
<a id="skip.navbar.top">
<!--   -->
</a>
<!-- ========= END OF TOP NAVBAR ========= -->
</div>
<div class="navPadding">&nbsp;</div>
<script type="text/javascript"><!--
$('.navPadding').css('padding-top', $('.fixedNav').css("height"));
//-->
</script>
</nav>
</header>
<!-- ======== START OF CLASS DATA ======== -->
<main role="main">
<div class="header">
<div class="subTitle"><span class="moduleLabelInType">Module</span>&nbsp;<a href="../../../module-summary.html">java.base</a></div>
<div class="subTitle"><span class="packageLabelInType">Package</span>&nbsp;<a href="package-summary.html">java.lang.invoke</a></div>
<h2 title="Class LambdaMetafactory" class="title">Class LambdaMetafactory</h2>
</div>
<div class="contentContainer">
<ul class="inheritance">
<li><a href="../Object.html" title="class in java.lang">java.lang.Object</a></li>
<li>
<ul class="inheritance">
<li>java.lang.invoke.LambdaMetafactory</li>
</ul>
</li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<hr>
<pre>public final class <span class="typeNameLabel">LambdaMetafactory</span>
extends <a href="../Object.html" title="class in java.lang">Object</a></pre>
<div class="block"><p>Methods to facilitate the creation of simple "function objects" that
 implement one or more interfaces by delegation to a provided <a href="MethodHandle.html" title="class in java.lang.invoke"><code>MethodHandle</code></a>,
 possibly after type adaptation and partial evaluation of arguments.  These
 methods are typically used as <em>bootstrap methods</em> for <code>invokedynamic</code>
 call sites, to support the <em>lambda expression</em> and <em>method
 reference expression</em> features of the Java Programming Language.

 <p>Indirect access to the behavior specified by the provided <code>MethodHandle</code>
 proceeds in order through three phases:
 <ul>
     <li><em>Linkage</em> occurs when the methods in this class are invoked.
     They take as arguments an interface to be implemented (typically a
     <em>functional interface</em>, one with a single abstract method), a
     name and signature of a method from that interface to be implemented, a
     method handle describing the desired implementation behavior
     for that method, and possibly other additional metadata, and produce a
     <a href="CallSite.html" title="class in java.lang.invoke"><code>CallSite</code></a> whose target can be used to create suitable function
     objects.  Linkage may involve dynamically loading a new class that
     implements the target interface. The <code>CallSite</code> can be considered a
     "factory" for function objects and so these linkage methods are referred
     to as "metafactories".</li>

     <li><em>Capture</em> occurs when the <code>CallSite</code>'s target is
     invoked, typically through an <code>invokedynamic</code> call site,
     producing a function object.  This may occur many times for
     a single factory <code>CallSite</code>.  Capture may involve allocation of a
     new function object, or may return an existing function object.  The
     behavior <code>MethodHandle</code> may have additional parameters beyond those
     of the specified interface method; these are referred to as <em>captured
     parameters</em>, which must be provided as arguments to the
     <code>CallSite</code> target, and which may be early-bound to the behavior
     <code>MethodHandle</code>.  The number of captured parameters and their types
     are determined during linkage.
     The identity of a function object produced by invoking the
     <code>CallSite</code>'s target is unpredictable, and therefore
     identity-sensitive operations (such as reference equality, object
     locking, and <code>System.identityHashCode()</code> may produce different
     results in different implementations, or even upon different invocations
     in the same implementation.</li>

     <li><em>Invocation</em> occurs when an implemented interface method
     is invoked on a function object.  This may occur many times for a single
     function object.  The method referenced by the behavior <code>MethodHandle</code>
     is invoked with the captured arguments and any additional arguments
     provided on invocation, as if by <a href="MethodHandle.html#invoke(java.lang.Object...)"><code>MethodHandle.invoke(Object...)</code></a>.</li>
 </ul>

 <p>It is sometimes useful to restrict the set of inputs or results permitted
 at invocation.  For example, when the generic interface <code>Predicate&lt;T&gt;</code>
 is parameterized as <code>Predicate&lt;String&gt;</code>, the input must be a
 <code>String</code>, even though the method to implement allows any <code>Object</code>.
 At linkage time, an additional <a href="MethodType.html" title="class in java.lang.invoke"><code>MethodType</code></a> parameter describes the
 "instantiated" method type; on invocation, the arguments and eventual result
 are checked against this <code>MethodType</code>.

 <p>This class provides two forms of linkage methods: a standard version
 (<a href="#metafactory(java.lang.invoke.MethodHandles.Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.invoke.MethodType,java.lang.invoke.MethodHandle,java.lang.invoke.MethodType)"><code>metafactory(MethodHandles.Lookup, String, MethodType, MethodType, MethodHandle, MethodType)</code></a>)
 using an optimized protocol, and an alternate version
 <a href="#altMetafactory(java.lang.invoke.MethodHandles.Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.Object...)"><code>altMetafactory(MethodHandles.Lookup, String, MethodType, Object...)</code></a>).
 The alternate version is a generalization of the standard version, providing
 additional control over the behavior of the generated function objects via
 flags and additional arguments.  The alternate version adds the ability to
 manage the following attributes of function objects:

 <ul>
     <li><em>Bridging.</em>  It is sometimes useful to implement multiple
     variations of the method signature, involving argument or return type
     adaptation.  This occurs when multiple distinct VM signatures for a method
     are logically considered to be the same method by the language.  The
     flag <code>FLAG_BRIDGES</code> indicates that a list of additional
     <code>MethodType</code>s will be provided, each of which will be implemented
     by the resulting function object.  These methods will share the same
     name and instantiated type.</li>

     <li><em>Multiple interfaces.</em>  If needed, more than one interface
     can be implemented by the function object.  (These additional interfaces
     are typically marker interfaces with no methods.)  The flag <code>FLAG_MARKERS</code>
     indicates that a list of additional interfaces will be provided, each of
     which should be implemented by the resulting function object.</li>

     <li><em>Serializability.</em>  The generated function objects do not
     generally support serialization.  If desired, <code>FLAG_SERIALIZABLE</code>
     can be used to indicate that the function objects should be serializable.
     Serializable function objects will use, as their serialized form,
     instances of the class <code>SerializedLambda</code>, which requires additional
     assistance from the capturing class (the class described by the
     <a href="MethodHandles.Lookup.html" title="class in java.lang.invoke"><code>MethodHandles.Lookup</code></a> parameter <code>caller</code>); see
     <a href="SerializedLambda.html" title="class in java.lang.invoke"><code>SerializedLambda</code></a> for details.</li>
 </ul>

 <p>Assume the linkage arguments are as follows:
 <ul>
      <li><code>invokedType</code> (describing the <code>CallSite</code> signature) has
      K parameters of types (D1..Dk) and return type Rd;</li>
      <li><code>samMethodType</code> (describing the implemented method type) has N
      parameters, of types (U1..Un) and return type Ru;</li>
      <li><code>implMethod</code> (the <code>MethodHandle</code> providing the
      implementation has M parameters, of types (A1..Am) and return type Ra
      (if the method describes an instance method, the method type of this
      method handle already includes an extra first argument corresponding to
      the receiver);</li>
      <li><code>instantiatedMethodType</code> (allowing restrictions on invocation)
      has N parameters, of types (T1..Tn) and return type Rt.</li>
 </ul>

 <p>Then the following linkage invariants must hold:
 <ul>
     <li>Rd is an interface</li>
     <li><code>implMethod</code> is a <em>direct method handle</em></li>
     <li><code>samMethodType</code> and <code>instantiatedMethodType</code> have the same
     arity N, and for i=1..N, Ti and Ui are the same type, or Ti and Ui are
     both reference types and Ti is a subtype of Ui</li>
     <li>Either Rt and Ru are the same type, or both are reference types and
     Rt is a subtype of Ru</li>
     <li>K + N = M</li>
     <li>For i=1..K, Di = Ai</li>
     <li>For i=1..N, Ti is adaptable to Aj, where j=i+k</li>
     <li>The return type Rt is void, or the return type Ra is not void and is
     adaptable to Rt</li>
 </ul>

 <p>Further, at capture time, if <code>implMethod</code> corresponds to an instance
 method, and there are any capture arguments (<code>K &gt; 0</code>), then the first
 capture argument (corresponding to the receiver) must be non-null.

 <p>A type Q is considered adaptable to S as follows:
 <table class="striped">
   <caption style="display:none">adaptable types</caption>
   <thead>
     <tr><th scope="col">Q</th><th scope="col">S</th><th scope="col">Link-time checks</th><th scope="col">Invocation-time checks</th></tr>
   </thead>
   <tbody>
     <tr>
         <th scope="row">Primitive</th><th scope="row">Primitive</th>
         <td>Q can be converted to S via a primitive widening conversion</td>
         <td>None</td>
     </tr>
     <tr>
         <th scope="row">Primitive</th><th scope="row">Reference</th>
         <td>S is a supertype of the Wrapper(Q)</td>
         <td>Cast from Wrapper(Q) to S</td>
     </tr>
     <tr>
         <th scope="row">Reference</th><th scope="row">Primitive</th>
         <td>for parameter types: Q is a primitive wrapper and Primitive(Q)
         can be widened to S
         <br>for return types: If Q is a primitive wrapper, check that
         Primitive(Q) can be widened to S</td>
         <td>If Q is not a primitive wrapper, cast Q to the base Wrapper(S);
         for example Number for numeric types</td>
     </tr>
     <tr>
         <th scope="row">Reference</th><th scope="row">Reference</th>
         <td>for parameter types: S is a supertype of Q
         <br>for return types: none</td>
         <td>Cast from Q to S</td>
     </tr>
   </tbody>
 </table></div>
<dl>
<dt><span class="simpleTagLabel">API Note:</span></dt>
<dd>These linkage methods are designed to support the evaluation
 of <em>lambda expressions</em> and <em>method references</em> in the Java
 Language.  For every lambda expressions or method reference in the source code,
 there is a target type which is a functional interface.  Evaluating a lambda
 expression produces an object of its target type. The recommended mechanism
 for evaluating lambda expressions is to desugar the lambda body to a method,
 invoke an invokedynamic call site whose static argument list describes the
 sole method of the functional interface and the desugared implementation
 method, and returns an object (the lambda object) that implements the target
 type. (For method references, the implementation method is simply the
 referenced method; no desugaring is needed.)

 <p>The argument list of the implementation method and the argument list of
 the interface method(s) may differ in several ways.  The implementation
 methods may have additional arguments to accommodate arguments captured by
 the lambda expression; there may also be differences resulting from permitted
 adaptations of arguments, such as casting, boxing, unboxing, and primitive
 widening. (Varargs adaptations are not handled by the metafactories; these are
 expected to be handled by the caller.)

 <p>Invokedynamic call sites have two argument lists: a static argument list
 and a dynamic argument list.  The static argument list is stored in the
 constant pool; the dynamic argument is pushed on the operand stack at capture
 time.  The bootstrap method has access to the entire static argument list
 (which in this case, includes information describing the implementation method,
 the target interface, and the target interface method(s)), as well as a
 method signature describing the number and static types (but not the values)
 of the dynamic arguments and the static return type of the invokedynamic site.</dd>
<dt><span class="simpleTagLabel">Implementation Note:</span></dt>
<dd>The implementation method is described with a method handle. In
 theory, any method handle could be used. Currently supported are direct method
 handles representing invocation of virtual, interface, constructor and static
 methods.</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>1.8</dd>
</dl>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- =========== FIELD SUMMARY =========== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="field.summary">
<!--   -->
</a>
<h3>Field Summary</h3>
<div class="memberSummary">
<table>
<caption><span>Fields</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colSecond" scope="col">Field</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tbody>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#FLAG_BRIDGES">FLAG_BRIDGES</a></span></code></th>
<td class="colLast">
<div class="block">Flag for alternate metafactories indicating the lambda object requires
 additional bridge methods</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#FLAG_MARKERS">FLAG_MARKERS</a></span></code></th>
<td class="colLast">
<div class="block">Flag for alternate metafactories indicating the lambda object implements
 other marker interfaces
 besides Serializable</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#FLAG_SERIALIZABLE">FLAG_SERIALIZABLE</a></span></code></th>
<td class="colLast">
<div class="block">Flag for alternate metafactories indicating the lambda object
 must be serializable</div>
</td>
</tr>
</tbody>
</table>
</div>
</li>
</ul>
</section>
<!-- ========== METHOD SUMMARY =========== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="method.summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<div class="memberSummary">
<div role="tablist" aria-orientation="horizontal"><button role="tab" aria-selected="true" aria-controls="memberSummary_tabpanel" tabindex="0" onkeydown="switchTab(event)" id="t0" class="activeTableTab">All Methods</button><button role="tab" aria-selected="false" aria-controls="memberSummary_tabpanel" tabindex="-1" onkeydown="switchTab(event)" id="t1" class="tableTab" onclick="show(1);">Static Methods</button><button role="tab" aria-selected="false" aria-controls="memberSummary_tabpanel" tabindex="-1" onkeydown="switchTab(event)" id="t4" class="tableTab" onclick="show(8);">Concrete Methods</button></div>
<div id="memberSummary_tabpanel" role="tabpanel">
<table aria-labelledby="t0">
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colSecond" scope="col">Method</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tbody>
<tr class="altColor" id="i0">
<td class="colFirst"><code>static <a href="CallSite.html" title="class in java.lang.invoke">CallSite</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#altMetafactory(java.lang.invoke.MethodHandles.Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.Object...)">altMetafactory</a></span>&#8203;(<a href="MethodHandles.Lookup.html" title="class in java.lang.invoke">MethodHandles.Lookup</a>&nbsp;caller,
              <a href="../String.html" title="class in java.lang">String</a>&nbsp;invokedName,
              <a href="MethodType.html" title="class in java.lang.invoke">MethodType</a>&nbsp;invokedType,
              <a href="../Object.html" title="class in java.lang">Object</a>...&nbsp;args)</code></th>
<td class="colLast">
<div class="block">Facilitates the creation of simple "function objects" that implement one
 or more interfaces by delegation to a provided <a href="MethodHandle.html" title="class in java.lang.invoke"><code>MethodHandle</code></a>,
 after appropriate type adaptation and partial evaluation of arguments.</div>
</td>
</tr>
<tr class="rowColor" id="i1">
<td class="colFirst"><code>static <a href="CallSite.html" title="class in java.lang.invoke">CallSite</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#metafactory(java.lang.invoke.MethodHandles.Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.invoke.MethodType,java.lang.invoke.MethodHandle,java.lang.invoke.MethodType)">metafactory</a></span>&#8203;(<a href="MethodHandles.Lookup.html" title="class in java.lang.invoke">MethodHandles.Lookup</a>&nbsp;caller,
           <a href="../String.html" title="class in java.lang">String</a>&nbsp;invokedName,
           <a href="MethodType.html" title="class in java.lang.invoke">MethodType</a>&nbsp;invokedType,
           <a href="MethodType.html" title="class in java.lang.invoke">MethodType</a>&nbsp;samMethodType,
           <a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;implMethod,
           <a href="MethodType.html" title="class in java.lang.invoke">MethodType</a>&nbsp;instantiatedMethodType)</code></th>
<td class="colLast">
<div class="block">Facilitates the creation of simple "function objects" that implement one
 or more interfaces by delegation to a provided <a href="MethodHandle.html" title="class in java.lang.invoke"><code>MethodHandle</code></a>,
 after appropriate type adaptation and partial evaluation of arguments.</div>
</td>
</tr>
</tbody>
</table>
</div>
</div>
<ul class="blockList">
<li class="blockList"><a id="methods.inherited.from.class.java.lang.Object">
<!--   -->
</a>
<h3>Methods declared in class&nbsp;java.lang.<a href="../Object.html" title="class in java.lang">Object</a></h3>
<code><a href="../Object.html#clone()">clone</a>, <a href="../Object.html#equals(java.lang.Object)">equals</a>, <a href="../Object.html#finalize()">finalize</a>, <a href="../Object.html#getClass()">getClass</a>, <a href="../Object.html#hashCode()">hashCode</a>, <a href="../Object.html#notify()">notify</a>, <a href="../Object.html#notifyAll()">notifyAll</a>, <a href="../Object.html#toString()">toString</a>, <a href="../Object.html#wait()">wait</a>, <a href="../Object.html#wait(long)">wait</a>, <a href="../Object.html#wait(long,int)">wait</a></code></li>
</ul>
</li>
</ul>
</section>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ============ FIELD DETAIL =========== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="field.detail">
<!--   -->
</a>
<h3>Field Detail</h3>
<a id="FLAG_SERIALIZABLE">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>FLAG_SERIALIZABLE</h4>
<pre>public static final&nbsp;int FLAG_SERIALIZABLE</pre>
<div class="block">Flag for alternate metafactories indicating the lambda object
 must be serializable</div>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../../constant-values.html#java.lang.invoke.LambdaMetafactory.FLAG_SERIALIZABLE">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a id="FLAG_MARKERS">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>FLAG_MARKERS</h4>
<pre>public static final&nbsp;int FLAG_MARKERS</pre>
<div class="block">Flag for alternate metafactories indicating the lambda object implements
 other marker interfaces
 besides Serializable</div>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../../constant-values.html#java.lang.invoke.LambdaMetafactory.FLAG_MARKERS">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a id="FLAG_BRIDGES">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>FLAG_BRIDGES</h4>
<pre>public static final&nbsp;int FLAG_BRIDGES</pre>
<div class="block">Flag for alternate metafactories indicating the lambda object requires
 additional bridge methods</div>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../../constant-values.html#java.lang.invoke.LambdaMetafactory.FLAG_BRIDGES">Constant Field Values</a></dd>
</dl>
</li>
</ul>
</li>
</ul>
</section>
<!-- ============ METHOD DETAIL ========== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="method.detail">
<!--   -->
</a>
<h3>Method Detail</h3>
<a id="metafactory(java.lang.invoke.MethodHandles.Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.invoke.MethodType,java.lang.invoke.MethodHandle,java.lang.invoke.MethodType)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>metafactory</h4>
<pre class="methodSignature">public static&nbsp;<a href="CallSite.html" title="class in java.lang.invoke">CallSite</a>&nbsp;metafactory&#8203;(<a href="MethodHandles.Lookup.html" title="class in java.lang.invoke">MethodHandles.Lookup</a>&nbsp;caller,
                                   <a href="../String.html" title="class in java.lang">String</a>&nbsp;invokedName,
                                   <a href="MethodType.html" title="class in java.lang.invoke">MethodType</a>&nbsp;invokedType,
                                   <a href="MethodType.html" title="class in java.lang.invoke">MethodType</a>&nbsp;samMethodType,
                                   <a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;implMethod,
                                   <a href="MethodType.html" title="class in java.lang.invoke">MethodType</a>&nbsp;instantiatedMethodType)
                            throws <a href="LambdaConversionException.html" title="class in java.lang.invoke">LambdaConversionException</a></pre>
<div class="block">Facilitates the creation of simple "function objects" that implement one
 or more interfaces by delegation to a provided <a href="MethodHandle.html" title="class in java.lang.invoke"><code>MethodHandle</code></a>,
 after appropriate type adaptation and partial evaluation of arguments.
 Typically used as a <em>bootstrap method</em> for <code>invokedynamic</code>
 call sites, to support the <em>lambda expression</em> and <em>method
 reference expression</em> features of the Java Programming Language.

 <p>This is the standard, streamlined metafactory; additional flexibility
 is provided by <a href="#altMetafactory(java.lang.invoke.MethodHandles.Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.Object...)"><code>altMetafactory(MethodHandles.Lookup, String, MethodType, Object...)</code></a>.
 A general description of the behavior of this method is provided
 <a href="LambdaMetafactory.html" title="class in java.lang.invoke"><code>above</code></a>.

 <p>When the target of the <code>CallSite</code> returned from this method is
 invoked, the resulting function objects are instances of a class which
 implements the interface named by the return type of <code>invokedType</code>,
 declares a method with the name given by <code>invokedName</code> and the
 signature given by <code>samMethodType</code>.  It may also override additional
 methods from <code>Object</code>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>caller</code> - Represents a lookup context with the accessibility
               privileges of the caller.  Specifically, the lookup context
               must have
               <a href="MethodHandles.Lookup.html#privacc">private access</a>
               privileges.
               When used with <code>invokedynamic</code>, this is stacked
               automatically by the VM.</dd>
<dd><code>invokedName</code> - The name of the method to implement.  When used with
                    <code>invokedynamic</code>, this is provided by the
                    <code>NameAndType</code> of the <code>InvokeDynamic</code>
                    structure and is stacked automatically by the VM.</dd>
<dd><code>invokedType</code> - The expected signature of the <code>CallSite</code>.  The
                    parameter types represent the types of capture variables;
                    the return type is the interface to implement.   When
                    used with <code>invokedynamic</code>, this is provided by
                    the <code>NameAndType</code> of the <code>InvokeDynamic</code>
                    structure and is stacked automatically by the VM.
                    In the event that the implementation method is an
                    instance method and this signature has any parameters,
                    the first parameter in the invocation signature must
                    correspond to the receiver.</dd>
<dd><code>samMethodType</code> - Signature and return type of method to be implemented
                      by the function object.</dd>
<dd><code>implMethod</code> - A direct method handle describing the implementation
                   method which should be called (with suitable adaptation
                   of argument types, return types, and with captured
                   arguments prepended to the invocation arguments) at
                   invocation time.</dd>
<dd><code>instantiatedMethodType</code> - The signature and return type that should
                               be enforced dynamically at invocation time.
                               This may be the same as <code>samMethodType</code>,
                               or may be a specialization of it.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a CallSite whose target can be used to perform capture, generating
         instances of the interface named by <code>invokedType</code></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="LambdaConversionException.html" title="class in java.lang.invoke">LambdaConversionException</a></code> - If any of the linkage invariants
                                   described <a href="LambdaMetafactory.html" title="class in java.lang.invoke"><code>above</code></a>
                                   are violated, or the lookup context
                                   does not have private access privileges.</dd>
</dl>
</li>
</ul>
<a id="altMetafactory(java.lang.invoke.MethodHandles.Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.Object...)">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>altMetafactory</h4>
<pre class="methodSignature">public static&nbsp;<a href="CallSite.html" title="class in java.lang.invoke">CallSite</a>&nbsp;altMetafactory&#8203;(<a href="MethodHandles.Lookup.html" title="class in java.lang.invoke">MethodHandles.Lookup</a>&nbsp;caller,
                                      <a href="../String.html" title="class in java.lang">String</a>&nbsp;invokedName,
                                      <a href="MethodType.html" title="class in java.lang.invoke">MethodType</a>&nbsp;invokedType,
                                      <a href="../Object.html" title="class in java.lang">Object</a>...&nbsp;args)
                               throws <a href="LambdaConversionException.html" title="class in java.lang.invoke">LambdaConversionException</a></pre>
<div class="block">Facilitates the creation of simple "function objects" that implement one
 or more interfaces by delegation to a provided <a href="MethodHandle.html" title="class in java.lang.invoke"><code>MethodHandle</code></a>,
 after appropriate type adaptation and partial evaluation of arguments.
 Typically used as a <em>bootstrap method</em> for <code>invokedynamic</code>
 call sites, to support the <em>lambda expression</em> and <em>method
 reference expression</em> features of the Java Programming Language.

 <p>This is the general, more flexible metafactory; a streamlined version
 is provided by <a href="#metafactory(java.lang.invoke.MethodHandles.Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.invoke.MethodType,java.lang.invoke.MethodHandle,java.lang.invoke.MethodType)"><code>metafactory(java.lang.invoke.MethodHandles.Lookup,
 String, MethodType, MethodType, MethodHandle, MethodType)</code></a>.
 A general description of the behavior of this method is provided
 <a href="LambdaMetafactory.html" title="class in java.lang.invoke"><code>above</code></a>.

 <p>The argument list for this method includes three fixed parameters,
 corresponding to the parameters automatically stacked by the VM for the
 bootstrap method in an <code>invokedynamic</code> invocation, and an <code>Object[]</code>
 parameter that contains additional parameters.  The declared argument
 list for this method is:

 <pre><code>
  CallSite altMetafactory(MethodHandles.Lookup caller,
                          String invokedName,
                          MethodType invokedType,
                          Object... args)
 </code></pre>

 <p>but it behaves as if the argument list is as follows:

 <pre><code>
  CallSite altMetafactory(MethodHandles.Lookup caller,
                          String invokedName,
                          MethodType invokedType,
                          MethodType samMethodType,
                          MethodHandle implMethod,
                          MethodType instantiatedMethodType,
                          int flags,
                          int markerInterfaceCount,  // IF flags has MARKERS set
                          Class... markerInterfaces, // IF flags has MARKERS set
                          int bridgeCount,           // IF flags has BRIDGES set
                          MethodType... bridges      // IF flags has BRIDGES set
                          )
 </code></pre>

 <p>Arguments that appear in the argument list for
 <a href="#metafactory(java.lang.invoke.MethodHandles.Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.invoke.MethodType,java.lang.invoke.MethodHandle,java.lang.invoke.MethodType)"><code>metafactory(MethodHandles.Lookup, String, MethodType, MethodType, MethodHandle, MethodType)</code></a>
 have the same specification as in that method.  The additional arguments
 are interpreted as follows:
 <ul>
     <li><code>flags</code> indicates additional options; this is a bitwise
     OR of desired flags.  Defined flags are <a href="#FLAG_BRIDGES"><code>FLAG_BRIDGES</code></a>,
     <a href="#FLAG_MARKERS"><code>FLAG_MARKERS</code></a>, and <a href="#FLAG_SERIALIZABLE"><code>FLAG_SERIALIZABLE</code></a>.</li>
     <li><code>markerInterfaceCount</code> is the number of additional interfaces
     the function object should implement, and is present if and only if the
     <code>FLAG_MARKERS</code> flag is set.</li>
     <li><code>markerInterfaces</code> is a variable-length list of additional
     interfaces to implement, whose length equals <code>markerInterfaceCount</code>,
     and is present if and only if the <code>FLAG_MARKERS</code> flag is set.</li>
     <li><code>bridgeCount</code> is the number of additional method signatures
     the function object should implement, and is present if and only if
     the <code>FLAG_BRIDGES</code> flag is set.</li>
     <li><code>bridges</code> is a variable-length list of additional
     methods signatures to implement, whose length equals <code>bridgeCount</code>,
     and is present if and only if the <code>FLAG_BRIDGES</code> flag is set.</li>
 </ul>

 <p>Each class named by <code>markerInterfaces</code> is subject to the same
 restrictions as <code>Rd</code>, the return type of <code>invokedType</code>,
 as described <a href="LambdaMetafactory.html" title="class in java.lang.invoke"><code>above</code></a>.  Each <code>MethodType</code>
 named by <code>bridges</code> is subject to the same restrictions as
 <code>samMethodType</code>, as described <a href="LambdaMetafactory.html" title="class in java.lang.invoke"><code>above</code></a>.

 <p>When FLAG_SERIALIZABLE is set in <code>flags</code>, the function objects
 will implement <code>Serializable</code>, and will have a <code>writeReplace</code>
 method that returns an appropriate <a href="SerializedLambda.html" title="class in java.lang.invoke"><code>SerializedLambda</code></a>.  The
 <code>caller</code> class must have an appropriate <code>$deserializeLambda$</code>
 method, as described in <a href="SerializedLambda.html" title="class in java.lang.invoke"><code>SerializedLambda</code></a>.

 <p>When the target of the <code>CallSite</code> returned from this method is
 invoked, the resulting function objects are instances of a class with
 the following properties:
 <ul>
     <li>The class implements the interface named by the return type
     of <code>invokedType</code> and any interfaces named by <code>markerInterfaces</code></li>
     <li>The class declares methods with the name given by <code>invokedName</code>,
     and the signature given by <code>samMethodType</code> and additional signatures
     given by <code>bridges</code></li>
     <li>The class may override methods from <code>Object</code>, and may
     implement methods related to serialization.</li>
 </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>caller</code> - Represents a lookup context with the accessibility
               privileges of the caller.  Specifically, the lookup context
               must have
               <a href="MethodHandles.Lookup.html#privacc">private access</a>
               privileges.
               When used with <code>invokedynamic</code>, this is stacked
               automatically by the VM.</dd>
<dd><code>invokedName</code> - The name of the method to implement.  When used with
                    <code>invokedynamic</code>, this is provided by the
                    <code>NameAndType</code> of the <code>InvokeDynamic</code>
                    structure and is stacked automatically by the VM.</dd>
<dd><code>invokedType</code> - The expected signature of the <code>CallSite</code>.  The
                    parameter types represent the types of capture variables;
                    the return type is the interface to implement.   When
                    used with <code>invokedynamic</code>, this is provided by
                    the <code>NameAndType</code> of the <code>InvokeDynamic</code>
                    structure and is stacked automatically by the VM.
                    In the event that the implementation method is an
                    instance method and this signature has any parameters,
                    the first parameter in the invocation signature must
                    correspond to the receiver.</dd>
<dd><code>args</code> - An <code>Object[]</code> array containing the required
                    arguments <code>samMethodType</code>, <code>implMethod</code>,
                    <code>instantiatedMethodType</code>, <code>flags</code>, and any
                    optional arguments, as described
                    <a href="#altMetafactory(java.lang.invoke.MethodHandles.Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.Object...)"><code>altMetafactory(MethodHandles.Lookup, String, MethodType, Object...)</code></a> above}</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a CallSite whose target can be used to perform capture, generating
         instances of the interface named by <code>invokedType</code></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="LambdaConversionException.html" title="class in java.lang.invoke">LambdaConversionException</a></code> - If any of the linkage invariants
                                   described <a href="LambdaMetafactory.html" title="class in java.lang.invoke"><code>above</code></a>
                                   are violated, or the lookup context
                                   does not have private access privileges.</dd>
</dl>
</li>
</ul>
</li>
</ul>
</section>
</li>
</ul>
</div>
</div>
</main>
<!-- ========= END OF CLASS DATA ========= -->
<footer role="contentinfo">
<nav role="navigation">
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a id="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<a id="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../index.html">Overview</a></li>
<li><a href="../../../module-summary.html">Module</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="class-use/LambdaMetafactory.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../index-files/index-1.html">Index</a></li>
<li><a href="../../../../help-doc.html">Help</a></li>
</ul>
<div class="aboutLanguage"><div style="margin-top: 14px;"><strong>Java SE 12 &amp; JDK 12</strong> </div></div>
</div>
<div class="subNav">
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li><a href="#field.summary">Field</a>&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li><a href="#field.detail">Field</a>&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
</div>
<a id="skip.navbar.bottom">
<!--   -->
</a>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</nav>
<p class="legalCopy"><small><a href="https://bugreport.java.com/bugreport/">Report a bug or suggest an enhancement</a><br> For further API reference and developer documentation see the <a href="https://docs.oracle.com/pls/topic/lookup?ctx=javase12.0.2&amp;id=homepage" target="_blank">Java SE Documentation</a>, which contains more detailed, developer-targeted descriptions with conceptual overviews, definitions of terms, workarounds, and working code examples.<br> Java is a trademark or registered trademark of Oracle and/or its affiliates in the US and other countries.<br> <a href="../../../../../legal/copyright.html">Copyright</a> &copy; 1993, 2019, Oracle and/or its affiliates, 500 Oracle Parkway, Redwood Shores, CA 94065 USA.<br>All rights reserved. Use is subject to <a href="https://www.oracle.com/technetwork/java/javase/terms/license/java12.0.2speclicense.html">license terms</a> and the <a href="https://www.oracle.com/technetwork/java/redist-137594.html">documentation redistribution policy</a>. <!-- Version 12.0.2+10 --></small></p>
</footer>
</body>
</html>
