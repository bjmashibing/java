<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Java Remote Method Invocation: 3 - RMI System Overview</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <link rel="stylesheet" href="../../resources/jdk-default.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<a href="index.html">CONTENTS</a> | <a href="objmodel.html">PREV</a> | <a href="client.html">NEXT</a>
<h1 id="rmi-system-overview">3 RMI System Overview</h1>
<ul>
<li><a href="#stubs-and-skeletons">Stubs and Skeletons</a></li>
<li><a href="#thread-usage-in-remote-method-invocations">Thread Usage in Remote Method Invocations</a></li>
<li><a href="#garbage-collection-of-remote-objects">Garbage Collection of Remote Objects</a></li>
<li><a href="#dynamic-class-loading">Dynamic Class Loading</a></li>
<li><a href="#rmi-through-firewalls-via-proxies">RMI Through Firewalls Via Proxies</a></li>
</ul>
<hr />
<h2 id="stubs-and-skeletons">3.1 Stubs and Skeletons</h2>
<p>RMI uses a standard mechanism (employed in RPC systems) for communicating with remote objects: <em>stubs</em> and <em>skeletons</em>. A stub for a remote object acts as a client's local representative or proxy for the remote object. The caller invokes a method on the local stub which is responsible for carrying out the method call on the remote object. In RMI, a stub for a remote object implements the same set of remote interfaces that a remote object implements.</p>
<p>When a stub's method is invoked, it does the following:</p>
<ul>
<li>initiates a connection with the remote JVM containing the remote object,</li>
<li>marshals (writes and transmits) the parameters to the remote JVM,</li>
<li>waits for the result of the method invocation,</li>
<li>unmarshals (reads) the return value or exception returned, and</li>
<li>returns the value to the caller.</li>
</ul>
<p>The stub hides the serialization of parameters and the network-level communication in order to present a simple invocation mechanism to the caller.</p>
<p>In the remote JVM, each remote object may have a corresponding skeleton (in Java 2 platform-only environments, skeletons are not required). The skeleton is responsible for dispatching the call to the actual remote object implementation. When a skeleton receives an incoming method invocation it does the following:</p>
<ul>
<li>unmarshals (reads) the parameters for the remote method,</li>
<li>invokes the method on the actual remote object implementation, and</li>
<li>marshals (writes and transmits) the result (return value or exception) to the caller.</li>
</ul>
<p>In the Java 2 SDK, Standard Edition, v1.2 an additional stub protocol was introduced that eliminates the need for skeletons in Java 2 platform-only environments. Instead, generic code is used to carry out the duties performed by skeletons in JDK1.1. Stubs and skeletons are generated by the <code>rmic</code> compiler.</p>
<h2 id="thread-usage-in-remote-method-invocations">3.2 Thread Usage in Remote Method Invocations</h2>
<p>A method dispatched by the RMI runtime to a remote object implementation may or may not execute in a separate thread. The RMI runtime makes no guarantees with respect to mapping remote object invocations to threads. Since remote method invocation on the same remote object may execute concurrently, a remote object implementation needs to make sure its implementation is thread-safe.</p>
<h2 id="garbage-collection-of-remote-objects">3.3 Garbage Collection of Remote Objects</h2>
<p>In a distributed system, just as in the local system, it is desirable to automatically delete those remote objects that are no longer referenced by any client. This frees the programmer from needing to keep track of the remote objects' clients so that it can terminate appropriately. RMI uses a reference-counting garbage collection algorithm similar to Modula-3's Network Objects. (See &quot;Network Objects&quot; by Birrell, Nelson, and Owicki, <em>Digital Equipment Corporation Systems Research Center Technical Report 115</em>, 1994.)</p>
<p>To accomplish reference-counting garbage collection, the RMI runtime keeps track of all live references within each Java virtual machine. When a live reference enters a Java virtual machine, its reference count is incremented. The first reference to an object sends a &quot;referenced&quot; message to the server for the object. As live references are found to be unreferenced in the local virtual machine, the count is decremented. When the last reference has been discarded, an unreferenced message is sent to the server. Many subtleties exist in the protocol; most of these are related to maintaining the ordering of referenced and unreferenced messages in order to ensure that the object is not prematurely collected.</p>
<p>When a remote object is not referenced by any client, the RMI runtime refers to it using a weak reference. The weak reference allows the Java virtual machine's garbage collector to discard the object if no other local references to the object exist. The distributed garbage collection algorithm interacts with the local Java virtual machine's garbage collector in the usual ways by holding normal or weak references to objects.</p>
<p>As long as a local reference to a remote object exists, it cannot be garbage-collected and it can be passed in remote calls or returned to clients. Passing a remote object adds the identifier for the virtual machine to which it was passed to the referenced set. A remote object needing unreferenced notification must implement the <code>java.rmi.server.Unreferenced</code> interface. When those references no longer exist, the <code>unreferenced</code> method will be invoked. <code>unreferenced</code> is called when the set of references is found to be empty so it might be called more than once. Remote objects are only collected when no more references, either local or remote, still exist.</p>
<p>Note that if a network partition exists between a client and a remote server object, it is possible that premature collection of the remote object will occur (since the transport might believe that the client crashed). Because of the possibility of premature collection, remote references cannot guarantee referential integrity; in other words, it is always possible that a remote reference may in fact not refer to an existing object. An attempt to use such a reference will generate a <code>RemoteException</code> which must be handled by the application.</p>
<h2 id="dynamic-class-loading">3.4 Dynamic Class Loading</h2>
<p>RMI allows parameters, return values and exceptions passed in RMI calls to be any object that is serializable. RMI uses the object serialization mechanism to transmit data from one virtual machine to another and also annotates the call stream with the appropriate location information so that the class definition files can be loaded at the receiver.</p>
<p>When parameters and return values for a remote method invocation are unmarshalled to become live objects in the receiving JVM, class definitions are required for all of the types of objects in the stream. The unmarshalling process first attempts to resolve classes by name in its local class loading context (the context class loader of the current thread). RMI also provides a facility for dynamically loading the class definitions for the actual types of objects passed as parameters and return values for remote method invocations from network locations specified by the transmitting endpoint. This includes the dynamic downloading of remote stub classes corresponding to particular remote object implementation classes (and used to contain remote references) as well as any other type that is passed by value in RMI calls, such as the subclass of a declared parameter type, that is not already available in the class loading context of the unmarshalling side.</p>
<p>To support dynamic class loading, the RMI runtime uses special subclasses of <code>java.io.ObjectOutputStream</code> and <code>java.io.ObjectInputStream</code> for the marshal streams that it uses for marshalling and unmarshalling RMI parameters and return values. These subclasses respectively override the <code>annotateClass</code> method of <code>ObjectOutputStream</code> and the <code>resolveClass</code> method of <code>ObjectInputStream</code> to communicate information about where to locate class files containing the definitions for classes corresponding to the class descriptors in the stream.</p>
<p>For every class descriptor written to an RMI marshal stream, the <code>annotateClass</code> method adds to the stream the result of calling <code>java.rmi.server.RMIClassLoader.getClassAnnotation</code> for the class object, which may be <code>null</code> or may be a <code>String</code> object representing the codebase URL path (a space-separated list of URLs) from which the remote endpoint should download the class definition file for the given class.</p>
<p>For every class descriptor read from an RMI marshal stream, the <code>resolveClass</code> method reads a single object from the stream. If the object is a String (and the value of the <code>java.rmi.server.useCodebaseOnly</code> property is not <code>true</code>), then <code>resolveClass</code> returns the result of calling <code>RMIClassLoader.loadClass</code> with the annotated <code>String</code> object as the first parameter and the name of the desired class in the class descriptor as the second parameter. Otherwise, <code>resolveClass</code> returns the result of calling <code>RMIClassLoader.loadClass</code> with the name of the desired class as the only parameter.</p>
<p>See the section <a href="server.html#the-rmiclassloader-class">&quot;The RMIClassLoader Class&quot;</a> for more details about class loading in RMI.</p>
<h2 id="rmi-through-firewalls-via-proxies">3.5 RMI Through Firewalls Via Proxies</h2>
<p>The implementation of RMI calls through firewalls via proxies has been removed as of JDK 9.</p>
<hr />
<p><em><a href="../../legal/copyright.html">Copyright</a> Â© 1997, 2017, Oracle and/or its affiliates. All rights reserved.</em></p>
<a href="index.html">CONTENTS</a> | <a href="objmodel.html">PREV</a> | <a href="client.html">NEXT</a>
</body>
</html>
